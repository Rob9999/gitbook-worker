\newcommand{\fallbackfeature}{}
\directlua{local fonts={"Twemoji Mozilla:mode=harf", "ERDA CC-BY CJK:mode=harf", "DejaVu Sans:mode=harf"}; local filtered={}; local function gbw_nonempty_table(t) return type(t) == 'table' and next(t) ~= nil end; for _, name in ipairs(fonts) do   local base = tostring(name):match('^([^:]+)') or name;   local ok1, info = pcall(function() return luaotfload.aux.provides_font(base) end);   if ok1 and type(info) == 'table' and info.filename then     table.insert(filtered, base);   else     texio.write_nl('log', 'luaotfload fallback skipped missing font: '..tostring(base));   end; end; gbw_fallback_stack = filtered; texio.write_nl('log', 'luaotfload fallback filtered='..table.concat(filtered, '; ')); if not gbw_nonempty_table(filtered) then   texio.write_nl('log', 'luaotfload fallback list empty; skipping add_fallback'); else   local ok2, err = pcall(function() luaotfload.add_fallback("mainfont", filtered) end);   if not ok2 then     texio.write_nl('log', 'luaotfload.add_fallback skipped: '..tostring(err));   else     local fb = luaotfload and luaotfload.fallbacks and luaotfload.fallbacks["mainfont"];     if gbw_nonempty_table(fb) then       if token and token.set_macro then token.set_macro('fallbackfeature', 'RawFeature={fallback=mainfont}', true); else texio.write_nl('log', 'gbw: token.set_macro unavailable; cannot set fallbackfeature'); end;     else       texio.write_nl('log', 'luaotfload.add_fallback produced empty data; skipping fallbackfeature');     end;   end; end}
\directlua{texio.write_nl('term and log', '*** GBW: Missing glyph detector initialized (abort=false)');gbw_missing_glyphs = gbw_missing_glyphs or {};local function gbw_font_name(fid)  local f = font.getfont(fid);  if not f then return tostring(fid) end;  return f.fullname or f.psname or f.name or tostring(fid);end;local function gbw_note_missing(fid, cp)  local entry = gbw_missing_glyphs[cp];  if not entry then entry = {fonts={}}; gbw_missing_glyphs[cp]=entry end;  entry.fonts[gbw_font_name(fid)] = true;  texio.write_nl('term and log', '*** GBW: Noted missing glyph U+'..string.format('%04X', cp)..' in font '..gbw_font_name(fid));end;local function gbw_check(head)  for n in node.traverse_id(node.id('glyph'), head) do    local fid = n.font; local cp = n.char;    if fid and cp then      local ok, has = pcall(font.has_glyph, fid, cp);      if (not ok) or (not has) then gbw_note_missing(fid, cp) end;    end  end;  return head;end;local function gbw_report()  texio.write_nl('term and log', '*** GBW: gbw_report() called');  if not gbw_missing_glyphs then texio.write_nl('term and log', '*** GBW: gbw_missing_glyphs is nil'); return end;  local keys = {}; for cp,_ in pairs(gbw_missing_glyphs) do keys[#keys+1]=cp end;  table.sort(keys);  texio.write_nl('term and log', '*** GBW: Found '..#keys..' missing glyph codepoints');  if #keys==0 then return end;  texio.write_nl('log', 'gbw missing glyph report ('..#keys..' codepoints)');  local fb = gbw_fallback_stack;  if type(fb) == 'table' and next(fb) ~= nil then     local okc, fb_str = pcall(function() return table.concat(fb, '; ') end);    if okc and fb_str then texio.write_nl('log', '  fallback stack: '..fb_str) end;  end;  local summary_lines = {};  for _,cp in ipairs(keys) do    local entry = gbw_missing_glyphs[cp];    local fonts = {}; for name,_ in pairs(entry.fonts or {}) do fonts[#fonts+1]=name end; table.sort(fonts);    local char_repr = ''; local ok,ch = pcall(function() return unicode.utf8.char(cp) end);    if ok and ch then char_repr = ' \"'..ch..'\"' end;    local line = string.format('  U+%04X%s missing in fonts: %s', cp, char_repr, table.concat(fonts, ', '));    texio.write_nl('log', line); summary_lines[#summary_lines+1]=line;  end;  if false then    texio.write_nl('term and log', '*** GBW: Aborting due to missing glyphs');    io.stderr:write('\\n=== GBW MISSING GLYPH ERROR ===\\n');    io.stderr:write('Found '..#keys..' codepoints with missing glyphs after fallback\\n');    if type(fb) == 'table' and next(fb) ~= nil then io.stderr:write('Fallback stack: '..table.concat(fb, '; ')..'\\n') end;    for _,l in ipairs(summary_lines) do io.stderr:write(l..'\\n') end;    io.stderr:write('=================================\\n');    io.stderr:flush();    tex.error('Missing glyphs after fallback', table.concat(summary_lines, '\\n'));  end;end;local lb = luatexbase or require('luatexbase');if lb and lb.add_to_callback then  texio.write_nl('term and log', '*** GBW: Registering callbacks');  lb.add_to_callback('hpack_filter', gbw_check, 'gbw-missing-glyphs-h');  lb.add_to_callback('pre_linebreak_filter', gbw_check, 'gbw-missing-glyphs-v');  lb.add_to_callback('finish_pdffile', gbw_report, 'gbw-missing-glyphs-report');  texio.write_nl('term and log', '*** GBW: Callbacks registered successfully');else  texio.write_nl('term and log', 'gbw missing glyph detector: luatexbase unavailable; skipping');end;}
\setmainfont[\fallbackfeature]{DejaVu Serif}
\setsansfont[\fallbackfeature]{DejaVu Sans}
\setmonofont[\fallbackfeature]{DejaVu Sans Mono}
